package com.tasks.AlishevJavaCollectionsCourses.AlishevConcurrency;

// volatile переменная не кэшируется из памяти ядра а каждый раз читается из общей памяти и таким образом значение
// переменной для всех потоков будет одинаковым

// synchronized - 2 и более потоков пишут в одну переменную, синхронизует работу 2х и более потоков при записис
// в общую переменную
public class AlishevVolatileOne {
    private int counter;

    public static void main(String[] args) throws InterruptedException {
        // new Object() каждому обьекту после его создания присваивается какая то сущность = МОНИТОР,
        // в 1 момент времени может быть только у 1го потока и ключевое слово synchronized использует эту особенность
        // только 1 поток может завладеть МОНИТОРОМ обьекта, МОНИТОР используется в Java чтобы дать понять Java
        // что этот поток взаимодействует с обьектом, поэтому другие обьекты не должны взаимодействовать с этим обьектом
        // они должны ждать, например МОНИТОР нужен чтобы получить доступ к полям обьекта и методам обьекта
        // МОНИТОР обьекта в один момент времени может принадлежать только 1му потоку
        AlishevVolatileOne alishevVolatileOne = new AlishevVolatileOne();
        alishevVolatileOne.doWork();
    }

    // synchronized - синхронизирует метод и все что внутри метода, Только 1 поток в одно время получает доступ
    // к телу метода, если мы почечаем метод synchronized, мы говорим о том что 1 поток выполняет в 1 момент времени
    // 2 потока не смогут исполнять одновременно тело метода, по один поток thread1 исполняет метод,
    // другой поток thread2 ждет, без разницы сколько потоков все будут ждать исполнения
    // synchronized - синхронизируется на обьекте this == обьект на который мы хотим синхронизироватся
    public synchronized void increment() {
        counter++;
    }

    /*
        1: 100 -> 101 -> 101 -> 102 -> 103, 1й записал 101, запись в потоках ведется хаотично и не контролируемо
        например операционная система выделила больше времени 1му потоку, потоки независимы друг от друга, не связаны
        для процессора, для компьютера они могут выполнятся в разное время
        2: 100 -> 101 -> 101 ->, 2й поток записал 101, потому что 1й поток оказался быстрее и тоже в ту же переменную
        записал 101
    */

    public void doWork() throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                // counter++; операция атомарна, выполняется не полностью, и из за этого в поток
                // записывается криво
                increment();
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++) {
                increment();
            }
        });

        thread1.start();
        thread2.start();

        // join - ждем результата выполнения 2х потоков, потому что поток main сразу нам выкенет counter = 0
        thread1.join(); // join мы говорим о том что хотим подождать когда завершится thread1 в текущем потоке main
        thread2.join();
        // но все равно в результать не будет записано значение которое нам нужно из за race condition, конкурентности потоков
        // race condition - это когда 2 потока пишут одновременно в одну переменную

        System.out.println(counter);
    }
}
