package com.tasks.AlishevJavaCollectionsCourses.AlishevConcurrency;

import java.util.Scanner;

// Volatile - ключевое слово необходимо тогда когда 1 поток читает из переменной, а другой поток записывает в переменную
// Volatile - изменчивый, подверженный изменению = обеспечивает конгирентность кэша каждого потока, убираем полностью
// проблему конгерентности кэшей
public class AlishevVolatile {
// Volatile - для того чтобы структурировать и упорядочить работу 2х и более потоков, существует синхронизация потоков
// Когда 1на переменная делится между несколькими потоками, когда 1 поток пишет в переменную а 1 или более потоков
// читают из этой переменной и тогда с ключевым словом volatile мы можем настроить взаимодействие этих потоков
// чтобы у разных потоков была одна и та же переменная которую они используют

    // ПОТОК ЗАПИСИ
    public static void main(String[] args) {
        MyThreadVolatile myThreadVolatile = new MyThreadVolatile();
        myThreadVolatile.start();
        // Теперь из потока main будем выключать поток MyThreadVolatile
        Scanner sc = new Scanner(System.in);
        sc.nextLine();
        // тут мы выключаем наше выполнение потока
        myThreadVolatile.shutdown();
    }
}

class MyThreadVolatile extends Thread {
    // Такой выключатель вреден тем что ядро на котором выполняется поток может продолжить читать переменную
    // из своего Кэша, а в кэшэ оно может остатся по тем же значением что и сейчас running = true; = Все Время!
    // конгирентность = совпадение, но бывают случаи когда наши кэш не совпадают, И может случится такое что
    // в ядре №1 где крутится поток main, в кэше running = false, а в ядре №2 потока MyThreadVolatile, в кэше running = true;
    // не совпадение кэшей
    // 1й поток ложит в кэш running = true, а потом ложит это значение в общую память, 2й поток берет из общей памяти
    // значение кэша к себе, но это в иделе, на практике такое может и не быть

    // Volatile - изменчивый, подверженный изменению = обеспечивает конгирентность кэша каждого потока, убираем полностью
    // проблему конгерентности кэшей
    // мы говорим о том что эта переменная может быть изменена, это значить что наша переменная не будет кэшироватся
    // в кэше каждого ядра, она всегда будет находится в Main Memory / Главной памяти, И каждый поток будет обращатся
    // к MainMemory, возможно в новыз операционных системах проблема конгирентности кэшей реализована
    private volatile boolean running = true;
// ПОТОК ЧТЕНИЯ
    public void run() {
        while (running) {
            System.out.println("Hello");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    // Такой выключение потока может не сработать из за плохой конгирентности кэша
    public void shutdown() {
        running = false;
    }

}
