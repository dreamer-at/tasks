package com.tasks.AlishevJavaCollectionsCourses.AAlgorithms;

import java.util.Arrays;

// Мощный, ком-р мощность - 1.000.000x
// Слабый, ком-р мощность - x
// Даем на вход 1000y аргумент
// Слабый комп-р с алгоритмом O(n) выполнит за 1000, потому что займет время пропорционально нашему аргументу
// Мощный ком-р (1/1.000.000)*2^1000*y, мощный ком-р не поможет, слишком высокая сложность алогримта 2^n, сложность
// алгоритма растет настолько быстро с ростом аргумента, что здесьб мощный комп-р не поможет

public class AFibonacci {
    // Число Фибоначчи равняется сумме 2х предыдущих чисел
    // Fn = Fn(n - 1) + (n - 2);
    // 0, 1, 1, 2, з, 5, 8, 13, 21, 34, 55, 89, 144
    public static void main(String[] args) {
        int n = 100;
        long[] mem = new long[n + 1];
        Arrays.fill(mem, -1); // Заполняем весь массив mem[] значением -1

        System.out.println(fibMemoize(n, mem));
        System.out.println(fibEffective(n));
    }

    // наивный, медленный, очевидный, число 100 будет вычислятся 50 000 лет
    // O(2^n) самый худший вариант
    private static long fibNaive(int n) {
        if (n <= 1) {
            return n;
        }

        return fibNaive(n - 2)  + fibNaive(n - 1);
    }

    // быстрый, мемоизация рекурсивного способа Фибоначчи, это сохранение промежуточного результата
    // O(n) почему такая оценка? Потому что его время выполнения растет пропорционально с ростом аргументов
    private static long fibMemoize(int n, long[] mem) {
        // если число на вход в памяти mem[n] имеется, взять это число, если нету дальше вычислить Фибоначчи
        // То есть при рекурсивном вычисленнии числа Фибоначчи, тут не будут повторно вычислятся операции, которые
        // уже рекурсивно вычислились в бинарном дереве выозов функции
        if (mem[n] != -1) {
            return mem[n];

        } if (n <= 1) {
            return n;
        }

        long result = fibMemoize(n - 1, mem) + fibMemoize(n - 2, mem);
        mem[n] = result;
        return result;
    }

    // более эффективный алгоритм, вычисление числа Фибонначи путем сложения 2х предудыщих чисел
    // не вычисляет лишние рекурсивные вызовы
    // O(n) почему такая оценка? Потому что его время выполнения растет пропорционально с ростом аргументов
    // O(n+n) = O(2n) = O(n)
    private static long fibEffective(int n) {
        // 1я => O(n)
        long[] arr = new long[n + 1];

        arr[0] = 0; // O(1) константная сложность, напрямую зависит от константы внутри, почему константа? потому что
        // сложность не зависит от аргумента n
        arr[1] = 1; // O(1)
        // 2я => O(n), Чем больше O(n) тем больше будет проводится итераций/операций цикла
        for (int i = 2; i <= n; i++) {
            // в i будем записывать сумму 1го и 2го чисел Фибоначчи
            arr[i] = arr[i - 1] + arr[i - 2];
        }
        return arr[n]; // O(1)
        // O(n) + O(1) + O(1) + O(n) + O(1) = O(2n) + O(3) = O(2n + 3) = O(n)
    }
}
