package com.tasks.AlgorithmsDataStructures;

public class GetIntegerArrayElementByIndex {
    public static void main(String[] args) {

        int [] integerArray = {10,6,4,23,87,111,12,1004};
        int indexOfRequiredElement = 5;

        if (indexOfRequiredElement < integerArray.length){
            int element = integerArray[indexOfRequiredElement];

            System.out.println(element);
        }
    }
}
//В данном случае, независимо от количества элементов в массиве
//мы выполняем фиксированное количество операций – если говорить грубо, то это 3 операции
// (проверка индекса, получение элемента по индексу, вывод в консоль). Это количество операций останетсятаким же и при 100 элементах в массиве, и при 1000000.
//Такая сложность называется константной и обозначается O(1).
//Стоит отметить, что если количество опраций всегда будет 100, то всё равно обозначение будет O(1).
//А если мы сложность O(10n), то финальное обозначение будет O(n). Это называется упрощением O-нотации.


//Примеры временной сложности
//Предположим, что у нас есть компания. В ней есть департаменты  (уникальное имя) и сотрудники (не уникальные имена).
// И сотрудники и департаменты имеют идентификатор (уникальный) и детальную информацию. Сущности упорядочены по имени.
// Мы можем вбить в описк только один параметр в поиск – имя. И в нашей системе периодически происходят сбои (то поиск полетит, то сортировка).
//O (1) – поиск детальной информации департамента по имени. Так как мы точно знаем, что имя департамента уникально,
// то вбив в поиск имя департамента – мы получим все данные по нему.
//O (1) лучший случай – мы ищем сотрудника по имени и первый в списке сотрудник оказывается тем, который нам нужен.
//O (n) – поиск детальной информации сотрудника по имени. Сортировка поломалась. В худшем случае, в нашей системе только сотрудники
// и все сотрудники имеют одинаковые имена (мир Эдуардов). В этом случае мы напрямую зависим от количества сотруников в системе.
// Нам придётся пройтись по всем сотрудникам и сравнивать по идентификатору и искать детальную информацию.
//O (log n) – у нас сломался поиск и мы просто видим страницы с сотрудниками и департаментами. Поиск по имени Кирилл. Допустим,
// у нас 100 страниц, на каждой из которых 50 сотрудников/департаментов. Упорядоченность по имени сохраняется.
// Мы открываем страницу 51 и смотрим первую запись и видим, что это Олег. Это означает, что страницы 51 – 100 точно не подходят. Мы переходим на страницу 25 – первая запись – Игорь. Отбрасываем страницы 1-25. Открываем страницу 13 и первое имя Кирилл с нужным нам идентификатором.
//Вы можете ознакомиться со сложностями базовых операций в базовых структурах данных (временных и по памяти) на это ресурсе:
//
//http://bigocheatsheet.com/
//
//На этом мы заканчиваем обзор структур данных и алгоритмов.